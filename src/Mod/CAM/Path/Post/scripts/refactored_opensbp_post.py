# ***************************************************************************
# *   Copyright (c) 2014 sliptonic <shopinthewoods@gmail.com>               *
# *   Copyright (c) 2022 - 2025 Larry Woestman <LarryWoestman2@gmail.com>   *
# *   Copyright (c) 2025 Alan Grover <awgrover@gmail.com>                   *
# *                                                                         *
# *   This file is part of the FreeCAD CAx development system.              *
# *                                                                         *
# *   This program is free software; you can redistribute it and/or modify  *
# *   it under the terms of the GNU Lesser General Public License (LGPL)    *
# *   as published by the Free Software Foundation; either version 2 of     *
# *   the License, or (at your option) any later version.                   *
# *   for detail see the LICENCE text file.                                 *
# *                                                                         *
# *   FreeCAD is distributed in the hope that it will be useful,            *
# *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
# *   GNU Lesser General Public License for more details.                   *
# *                                                                         *
# *   You should have received a copy of the GNU Library General Public     *
# *   License along with FreeCAD; if not, write to the Free Software        *
# *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
# *   USA                                                                   *
# *                                                                         *
# ***************************************************************************

import sys
import re
import argparse
from copy import copy
import operator
import math

from typing import Any, Dict, List, Optional, Tuple, Union

from Path.Post.Processor import PostProcessor
import Path.Post.UtilsArguments as PostUtilsArguments
import Path.Post.UtilsExport as PostUtilsExport
import Path.Post.UtilsParse as PostUtilsParse

import Path
import FreeCAD

translate = FreeCAD.Qt.translate

DEBUG = False
if DEBUG:
    Path.Log.setLevel(Path.Log.Level.DEBUG, Path.Log.thisModule())
    Path.Log.trackModule(Path.Log.thisModule())
else:
    Path.Log.setLevel(Path.Log.Level.INFO, Path.Log.thisModule())

#
# Define some types that are used throughout this file.
#
Defaults = Dict[str, bool]
FormatHelp = str
GCodeOrNone = Optional[str]
GCodeSections = List[Tuple[str, GCodeOrNone]]
Parser = argparse.ArgumentParser
ParserArgs = Union[None, str, argparse.Namespace]
Postables = Union[List, List[Tuple[str, List]]]
Section = Tuple[str, List]
Sublist = List
Units = str
Values = Dict[str, Any]
Visible = Dict[str, bool]
nl = "\n" # particularly useful in a f-string

class Refactored_Opensbp(PostProcessor):
    """
    For ShopBot (or other opensbp controllers), this is a CAM postprocessor. We have to
    translate gcode to opensbp, so the output is NOT gcode.

    Special behaviors:
    * This always sets the ShopBot app/machine units (see --inches --metric), no more mismatches. This defaults to your document's units.
    * G54 (fixture/coordinate-system) is accepted, but is a noop (because it's the default in Operations). Others (G55 etc) are not-accepted.
    * This does arc gcodes (G02 and G03), so helical operations should work.
    * Like most post-processors, we accept single-digit gcodes like G1, and treat them as if they were canonical 2 digit, like G01.
    * opensbp commands can be in-lined with a comment:
            (MC_RUN_COMMAND: <opensbpcommand>)
    * By default, this post-processor fails if it sees a gcode it doesn't understand. Cf. --abort-on-unknown and --skip-unknown
    * opensbp prompt (dialog-box) behavior like this:
        (this comment becomes a prompt if followed by M00)
        M00
    * Most optimizations assume that the instruction stream isn't interrupted with manually added commands (e.g. assumes the xyz position from the previous instructions). So, don't stop, and insert commands if you've used any of the optimizations.
    * This always sets the move & jog speeds (feed and rapid) at the beginning of an operation, by fetching the Tool speeds (because some operations omit initial speeds).
    * This does not filter out an operations's initial G0 X0 Y0 Z$safe, which is egregiously generated by some operations (notably dressups).
    * If a Tool has a spindle speed, this always generates a dialog-box to prompt you.
    * This generates a dialog-box for manual Tool changes (if it is a change), but not for the first tool (this assumes you've chucked the first tool).
    * There is only very basic support for the A and B axis. This will probably do the wrong thing if not absolute degrees.
    """

    def __init__(self, job) -> None:
        super().__init__(
            job=job,
            tooltip=translate("CAM", "see property below"),
            tooltipargs=[""],
            units="Metric",
        )
        self.reinitialize()
        Path.Log.debug("Refactored opensbp post processor initialized.")

    def reinitialize(self) -> None:
        """Initialize or reinitialize the 'core' data structures for the postprocessor."""
        #
        # This is also used to reinitialize the data structures between tests.
        #
        self.values: Values = {}
        self.init_values(self.values)
        #debug_str = "\n".join(f"{k}:{self.values[k]}" for k in sorted(self.values.keys())); print(f"### .values\n{debug_str}")

        self.argument_defaults: Defaults = {}
        self.init_argument_defaults(self.argument_defaults)
        print(f"### .argument_defaults\n{self.argument_defaults}")
        self.arguments_visible: Visible = {}
        self.init_arguments_visible(self.arguments_visible)
        self.parser: Parser = self.init_arguments(
            self.values, self.argument_defaults, self.arguments_visible
        )
        self.arguments = None # the parser.parse_args result

        #
        # Create another parser just to get a list of all possible arguments
        # that may be output using --output_all_arguments.
        #
        self.all_arguments_visible: Visible = {}
        for k in iter(self.arguments_visible):
            self.all_arguments_visible[k] = True
        self.all_visible: Parser = self.init_arguments(
            self.values, self.argument_defaults, self.all_arguments_visible
        )

    def init_values(self, values: Values) -> None:
        """Initialize values that are used throughout the postprocessor."""
        #
        PostUtilsArguments.init_shared_values(values)
        #
        # Set any values here that need to override the default values set
        # in the init_shared_values routine.
        #

        # Used in the argparser code as the "name" of the postprocessor program.
        values["MACHINE_NAME"] = "Refactored_opensbp"

        values.update({
            'DRILL_CYCLES_TO_TRANSLATE' : [ "G73", "G81", "G82", "G83", "G85" ],
            "ENABLE_COOLANT" : False,
            'ENABLE_MACHINE_SPECIFIC_COMMANDS' : True,
            'LINE_INCREMENT' : 1,
            'OUTPUT_ADAPTIVE' : True,
            'OUTPUT_PATH_LABELS' : True,
            # 'PARAMETER_ORDER' : don't care, we aren't gcode
            "POSTAMBLE" : "",
            "POSTPROCESSOR_FILE_NAME" : __name__,
            "PREAMBLE" : "",
            'SPINDLE_WAIT' : 3, # for manual case
            'STOP_SPINDLE_FOR_TOOL_CHANGE' : False,
            'SUPPRESS_COMMANDS' : [ 'G54' ], # we don't have coord-systems (yet)
            # 'TOOL_CHANGE' : we have to generate this dynamically
            'TRANSLATE_DRILL_CYCLES' : True,
            "UNITS" : self._units,
            'UNIT_SPEED_FORMAT' : 'mm/s',
            'USE_TLO' : False,
            'line_number' : 1,
            'SKIP_UNKNOWN' : [], # --skip-unknown
        })


    def init_argument_defaults(self, argument_defaults: Defaults) -> None:
        """Initialize which arguments (in a pair) are shown as the default argument."""
        #
        # Modify which argument to show as the default in flag-type arguments here.
        # If the value is True, the first argument will be shown as the default.
        # If the value is False, the second argument will be shown as the default.
        #
        # For example, if you want to show Metric mode as the default, use:
        #   argument_defaults["metric_inch"] = True
        #
        # If you want to show that "Don't pop up editor for writing output" is
        # the default, use:
        #   argument_defaults["show-editor"] = False.
        PostUtilsArguments.init_argument_defaults(argument_defaults)
        #
        # Note:  You also need to modify the corresponding entries in the "values" hash
        #        to actually make the default value(s) change to match.
        #

        argument_defaults['tlo'] = False
        # argument_defaults['metric_inches'] = True if From doc
        argument_defaults['translate_drill'] = True


    def init_arguments_visible(self, arguments_visible: Visible) -> None:
        """Initialize which argument pairs are visible in TOOLTIP_ARGS."""
        PostUtilsArguments.init_arguments_visible(arguments_visible)
        #
        # Modify the visibility of any arguments from the defaults here.
        #
        arguments_visible.update( { k:False for k in [
            'bcnc', 'tlo', 'translate_drill'
        ] } )
        print(f"### arguments_visible {arguments_visible}")

    def init_arguments(
        self,
        values: Values,
        argument_defaults: Defaults,
        arguments_visible: Visible,
    ) -> Parser:
        """Initialize the shared argument definitions."""

        _parser: Parser = PostUtilsArguments.init_shared_arguments(
            values, argument_defaults, arguments_visible
        )
        #
        # Add any argument definitions that are not shared with all other
        # postprocessors here.
        #
        _parser.add_argument(
            "--native-preamble",
            help='verbatim opensbp commands to be issued before the first command, multi-line w/ \\n. Before preamble. Consider a "Cn" or "FB". default=None',
        )
        _parser.add_argument(
            "--native-postamble",
            help='verbatim opensbp commands to be issued after the last command, multi-line w/ \\n. After postamble. Consider a "Cn" or "FB". default=None',
        )
        # parser.add_argument("--o1", action="store_true", help='turns on optimizations that wouldn't break if you interrupt the execution and did some command manually.') # no such optimizations at this time
        # These optimizations assume that you don't interrupt execution to insert a manual command (e.g. imagine a MS 400; and MX,1. which would break all the modal assumptions)
        _parser.add_argument("--o2", action="store_true", help='turns on --modal --axis-modal --speed-modal')
        _parser.add_argument("--speed-modal", action=argparse.BooleanOptionalAction, help="Shorten output when speed-values don't change", default=False)
        _parser.add_argument(
            # this should probably be True for most shopbot installations
            "--ab-is-distance", action="store_true", help="A & B axis are distances, default=degrees"
        )
        _parser.add_argument("--filter","--filters", help="a ',' list of filters in FreeCAD.getUserMacroDir()/post to run on the gcode of each Path object, before we see it (i.e. cleanups). A class of same (camelcase) name as file, __init__(self,objectslist, filename, argstring), .filter(eachpathobj, its-.Commands) -> gcode")
        _parser.add_argument("--abort-on-unknown", action=argparse.BooleanOptionalAction, help="Generate an error and fail if an unknown gcode is seen. default=True", default=True)
        _parser.add_argument("--skip-unknown", help="if --abort-on-unknown, allow these gcodes, change them to a comment. E.g. --skip-unknown G55,G56")
        _parser.add_argument("--toolchanger", action=argparse.BooleanOptionalAction, help="Use auto-tool-changer (macro C9), default=manual", default=False)
        _parser.add_argument("--spindle-controller", action=argparse.BooleanOptionalAction, help="Has software controlled spindle speed, default=manual", default=False)
        _parser.add_argument("--gcode-comments", action=argparse.BooleanOptionalAction, help="Add the original gcode as a comment, for debugging", default=False)

        return _parser

    def process_arguments(self) -> Tuple[bool, ParserArgs]:
        """Process any arguments to the postprocessor."""
        #
        # This function is separated out to make it easier to inherit from this postprocessor
        #
        args: ParserArgs
        flag: bool

        (flag, args) = PostUtilsArguments.process_shared_arguments(
            self.values, self.parser, self._job.PostProcessorArgs, self.all_visible, "-"
        )
        #
        # If the flag is True, then all of the arguments should be processed normally.
        #
        if flag:
            #
            # Process any additional arguments here.
            #
            #
            # Update any variables that might have been modified while processing the arguments.
            #
            self._units = self.values["UNITS"]
        #
        # If the flag is False, then args is either None (indicating an error while
        # processing the arguments) or a string containing the argument list formatted
        # for output.  Either way the calling routine will need to handle the args value.
        #
        return (flag, args)

    def process_postables(self) -> GCodeSections:
        """Postprocess the 'postables' in the job to g code sections."""
        #
        # This function is separated out to make it easier to inherit from this postprocessor.
        #
        gcode: GCodeOrNone
        g_code_sections: GCodeSections
        partname: str
        postables: Postables
        section: Section
        sublist: Sublist

        postables = self._buildPostList()

        Path.Log.debug(f"postables count: {len(postables)}")

        g_code_sections = []
        # a section seems to be for one output file of gcode (a "split")
        for _, section in enumerate(postables):
            # partname is "allitems" if not splitting, and the operation/etc. if splitting
            # sublist is each "phase" of the operation, like Fixture, ToolController, Operation
            partname, sublist = section
            print(f"### export_common for {partname} {[o.Name for o in sublist]}")

            # We have to lie about self.values to get some expanded g-code that we rely on
            # e.g. we rely on comments
            was_values = copy(self.values)
            self.values.update({
                'OUTPUT_COMMENTS' : True, # we use this to detect operation and...
                'OUTPUT_TOOL_CHANGE' : True, # we need this to ensure speeds
                'SHOW_MACHINE_UNITS' : True, # we have to set the machine
                'AXIS_PRECISION' : 5, # we do calculations, so more precision to prevent rounding errors
                'FEED_PRECISION' : 5,
            })
            try:
                # We get back a processed (expanded) set of gcode
                # things like pre/post amble, canned-drill expansion, coolant on/off
                # We could note where each `partname` begins, if we need that
                #   but we get no access to where each `sublist` starts/ends
                # `gcode` is a multi-line string
                gcode = PostUtilsExport.export_common(self.values, sublist, "-")
            finally:
                self.values = was_values

            print(f"### Gcode common'd {gcode.__class__.__name__} {len(gcode.split(nl))}")
            print(f"-gcode expanded-\n{gcode}--")

            # ToOpenSBP will modify our .values, and not restore them
            was_values = copy(self.values)
            try:
                # Treat each `sublist` as a unit/file, so new instance
                native = ToOpenSBP(self).translate( gcode )
            finally:
                self.values = was_values

            g_code_sections.append((partname, native))

        return g_code_sections

    def export(self) -> GCodeSections:
        """Process the parser arguments, then postprocess the 'postables'."""
        args: ParserArgs
        flag: bool

        Path.Log.debug("Exporting the job")

        (flag, args) = self.process_arguments()
        #
        # If the flag is True, then continue postprocessing the 'postables'
        #
        if flag:
            self.arguments = args
            print(f"### argparsed {args}")
            return self.process_postables()
        #
        # The flag is False meaning something unusual happened.
        #
        # If args is None then there was an error during argument processing.
        #
        if args is None:
            return None
        #
        # Otherwise args will contain the argument list formatted for output
        # instead of the "usual" gcode.
        #
        return [("allitems", args)]  # type: ignore

    @property
    def tooltip(self):
        return self.__doc__

    @property
    def tooltipArgs(self) -> FormatHelp:
        return self.parser.format_help()

    @property
    def units(self) -> Units:
        return self._units


def gcode(*commands):
    """Only for use in class ToOpenSBP.
    Decorator to add the function to the translate-map.
        `commands` is list of Gcodes, i.e. "G54", "G55",
        specify two digit gcode: e.g. "G01", "M06"
    """
    def gcode(func):
        # we really just want to make a map with it
        # But, we want the map to belong to the class
        # which doesn't exist at "use" time
        # so, annotate the method
        # and collect/insert after the class
        func._gcode = []
        for c in commands:
            func._gcode.append( c )
            canonical = re.sub(r'^([A-Z])(\d(\.|$))', r'\g<1>0\2', c)
            if canonical != c:
                raise Exception(f"Internal: Must be a 2 digit gcode (e.g. G00): @gcode('{c}')")

        # null wrapper
        # FIXME: I think if we wrap it, then do obj.func(args), we'll get proper inhertance dispatch
        return func

    return gcode

def gcode_insertmap():
    # see gcode() above. this inserts the map
    for name, attr in ToOpenSBP.__dict__.items():
        if callable(attr) and hasattr(attr, "_gcode"):
            for g in attr._gcode:
                ToOpenSBP.DispatchMap[g] = attr
    print(f"### DispatchMap {[x for x in sorted(ToOpenSBP.DispatchMap.keys())]}")

class ToOpenSBP:
    """Translate gcode to opensbp
    """

    AllowedAxis = 'XYZAB' # though AB is barely supported here

    DispatchMap = {}

    VDCommand = { 
        'inches' : "VD,,,0", 
        'metric' : "VD,,,1" 
    }
    # aliases for other uses
    VDCommand['G20'] = VDCommand['inches']
    VDCommand['G21'] = VDCommand['metric']

    def __init__(self, postprocessor : Refactored_Opensbp):
        # we will use specific features (.values[x] and arguments from the opensbp post)
        self.post = postprocessor

        # xyzf etc state
        self.current_location = { p:None for p in self.post.values["PARAMETER_ORDER"] } 
        self.current_location['JSXY'] = None
        self.current_location['JSZ'] = None

        self.set_units = None # flag and memory of the first time we see a G20/G21 set-units
        self._postfix = [] # balancing things to add to end

    def translate(self, gcode ):
        """Entry point, returns the translated contents, e.g. opensbp lines.
        We rely on self.post to hold some state vars: we reuse self.post.values.
        We have lost most context, and structuring of the gcode/job at this point, 
        and the export_common() has potentially inserted and translated stuff.
        This makes it harder to do stuff like --native-preamble.
        So, we repeat some logic from UtilsParse, like "is this a tool change?", etc.
        Line-numbers are also lost, and won't match the "inspect toolpath commands" g-code.
        We do have self.post._job
        """
        native = ""
        before_len = len(gcode.split(nl))

        # We reuse the postprocessor.values
        # So, we have to reset some values
        self.reset_values()
        print(f"### post.values {self.post.values}")

        for gcode_line in gcode.split(nl):
            self.post.values["line_number"] += 1 # actual line number

            # we need Path.Commands to work with
            path_command = self.to_path_command(gcode_line, f"expanded gcode line {self.post.values['line_number']}")
            if path_command is None:
                continue
            print(f"### GCODE [{self.post.values['line_number']}] {path_command.toGCode()}")

            # And now we reproduce most of UtilsParse.parse_a_path

            self.track_by_comments( path_command )

            if self.post.arguments.gcode_comments and not path_command.Name.startswith('('):
                native += self.comment( f"[{self.post.values['line_number']}] {path_command.toGCode()}" )

            print(f"### path_command is {path_command.__class__.__name__}")
            rez = self.dispatch( path_command )
            sys.stdout.write(f"### translated: {rez}")
            native += rez
            
            self.current_location.update(path_command.Parameters)
            print(f"### current {self.current_location}")
            
        native += self.postfix()

        print(f"### GCode {before_len} -> {len(native.split(nl))}")
        return native

    def postfix(self):
        rez = nl.join( self._postfix )
        if rez:
            rez += nl
        return rez
        
    def reset_values(self):
        self.post.values.update({
            'line_number' : 0,
            'COMMENT_SYMBOL' : "'",
        })

    def track_by_comments(self, path_command ):
        """Since we've lost the Path objects structure (we only have the gcode str),
        we'll track things of interest by comments here.
        """
        if path_command.Name.startswith('('):
            if m := (
                re.match(r'\(Begin operation: ([^)]+)\)', path_command.Name)
                or
                re.match(r'\(Begin (preamble)\)', path_command.Name)
                ):
                self.post.values['Operation'] = m.group(1)

    def to_path_command(self, gcode : str, during : str):
        """Utility,
        One gcode line to a Path.Command, with some error handling
        e.g. to_path_command("G0 X50", "preamble")
        `during` is explanatory text if we get a conversion error
        """

        if gcode == '':
            return None

        pc = Path.Command()
        try:
            pc.setFromGCode(gcode)
        except ValueError as e:
            # can't tell if it is really 'Badly formatted GCode argument', so just add our gcode to the message
            message = f"During {during}, {self.location(gcode)}"
            FreeCAD.Console.PrintError(message)
            raise ValueError(message) from e
        return pc

    def dispatch(self, path_command):
        """The whole point of this class is to put the translate stuff in a modular-unit,
        and translate g-codes.
        So, each gcode maps to a function that handles it,
        so, we use @gcode decorators to collect the gcodes and functions,
        and we dispatch here.
        We return a string, which might be multi-line,
        or '' to mean nothing resulted
        """
        command = None
        if path_command.Name.startswith('('):
            # sadly, Path.Command doesn't set .Name to "comment", but rather to the comment string
            command = 'comment'
        else:
            # canonicalize to 2 digits
            # All the @gcode() methods can now assume 2 digits
            path_command.Name = re.sub(r'^([A-Z])(\d(\.|$))', r'\g<1>0\2', path_command.Name)
            command = path_command.Name

        if command in self.DispatchMap:
            rez = self.DispatchMap[command](self, path_command ) # careful, doesn't do inheritance lookup
            return rez
        else:
            message = f"gcode not handled at {self.location(path_command)}"
            if self.post.arguments.abort_on_unknown and command not in self.post.values['SKIP_UNKNOWN']:
                FreeCAD.Console.PrintError(message+"\n")
                raise NotImplementedError(message)
            else:
                FreeCAD.Console.PrintWarning("Skipped:  " + message + "\n")
                return self.comment(message, force=True) # FIXME: remove force

    def location(self, path_command=None):
        """a message fragment of where we are, and the path_command if you want
            `path_command` can be a literal-string gcode, or usually a Path.Command
        """
        g = f": {path_command if isinstance(path_command, str) else path_command.toGCode()}" if path_command else ''
        return f"[{self.post.values['line_number']}] in {self.post.values['Operation']}{g}"

    def comment(self, message, force=False):
        """if OUTPUT_COMMENTS, then generate the comment, 
        `force` ignores OUTPUT_COMMENTS and always generates.
        INCLUDES the \n (nl)!
        """
        # note that comments from FreeCAD and export_common are strings with "()"
        # so, you can't tell what comments came from a Path operation object, or from Path/Post utils
        # and the parenthesis are preservered, so the final looks like '(blah blah)
        # Comments from this postprocessor are w/o (), so the final looks like 'our comment
        if self.post.values["OUTPUT_COMMENTS"] or force:
            return self.post.values["COMMENT_SYMBOL"] + message + nl
        else:
            return ''

    @gcode('comment')
    def t_comment(self, path_command):
        rez = self.comment(path_command.Name)

        # fixups
        if path_command.Name.startswith("(Post Processor: "):
            rez += self.comment( "  " + self.post._job.PostProcessorArgs )
        if path_command.Name.startswith("(Cam File: "):
            rez += self.comment(f"Job: {self.post._job.Label}")

        return rez

    @gcode('G20', 'G21')
    def t_units(self, path_command):
        if self.set_units:
            raise ValueError("You can only set the units once, already {self.set_units['command']} at {self.set_units['at']}. You tried again at {self.location(path_command)}")
        else:
            self.set_units = { 'command' : path_command.Name, 'at' : self.location() }
            rez = [
                "&WASUNITS=%(25)",
                self.comment(f"Units {'inches' if path_command.Name=='G20' else 'metric'}")
                    + self.VDCommand[ path_command.Name ],
            ]

            self._postfix.append( "VD,,,&WASUNITS" ) # restore at end

            return nl.join(rez) + nl

    @gcode('G90') # no relative (G91) yet
    def t_absolute_mode(self, path_command):
        return { 'G90':'SA', 'G91':'SR' }[ path_command.Name ] + nl

    @gcode('M06')
    def t_toolchange(self, path_command):
        if self.post.values['OUTPUT_TOOL_CHANGE']:
            tool_number = int(path_command.Parameters['T'])
            tool_name = "<fixme>" # CurrentState['ToolController'].Tool.Label if CurrentState['ToolController'] else str(tool_number)
            tool_controller = self.post._job.Tools.Group[ tool_number - 1 ]
            tool_name = f"{tool_controller.Label}, {tool_controller.Tool.Label}" # not sure if we want both .Label's, just trying to help the operator
            safe_tool_name = re.sub(r'[^A-Za-z0-9/_ .-]', '', tool_name)

            if self.post.arguments.toolchanger:
                rez = [
                    f"&Tool={tool_number}",
                    "C9 'toolchanger",
                    f'&ToolName="{safe_tool_name}"', 
                ]
            else:
                rez = [
                    f"&Tool={tool_number}",
                    f"'Change tool to #{tool_number}: {tool_name}", # prompt
                    "PAUSE", # causes a modal to show message and ask "ok?"
                    f'&ToolName="{safe_tool_name}"', 
                ]
                
            rez = nl.join(rez) + nl
        else:
            rez = ''

        rez += self.set_initial_speeds(tool_controller, path_command)

        return rez

    @gcode("G00", "G01")
    def t_move(self, path_command):
        """Oh boy.
        opensbp specifies the x, y speed, and Z speed separately for a motion.
        e.g. a "MS,sx,sy,sz" then a "M3,x,y,z".
        Gcode has a F which the speed of the vector
        and, for rapid, it's whatever-the-machine-setting-is.
        FreeCAD has horizontal speed (xy), and vertical speed (z),
        which it uses to calculate F.
        And, we should respect the Rapid speeds, 
        so we pull rapid at set_initial_speed() time for each tool-change.
        Finally, we have to take the delta(x,y,z) vector and project the F (or rapid) speed onto each axis,
        to generate the MS or JS command before each move command.
        The Mx or Jx just uses the axis distances.
        """
        rez = ''

        # Optimize the command, specifying 1..5 axis values
        # XYZABC, but reversed
        r_axis = [ path_command.Parameters.get(a,None) for a in reversed(self.AllowedAxis) ]
        first_not_none = 0
        for i,a in enumerate(r_axis):
            if a is not None:
                first_not_none = i
                break
        print(f"### specified r_axis {r_axis}[{first_not_none}:]")
        axis = list(reversed(r_axis[first_not_none:]))
        print(f"### specified axis {axis}")

        if feed_rate := path_command.Parameters.get('F', None):
            if path_command.Name == 'G00':
                if self.post.arguments.abort_on_unknown:
                    raise ValueError(f"Rapid moves (G0) can't have an F at {self.location(path_command)}")

        print(f"### move {path_command.Name} F {feed_rate}")
        rez += self.set_speed( path_command, feed_rate )

        native_command = 'J' if path_command.Name == 'G00' else "M"
        axis_ct = len(axis)
        if axis_ct == 1:
            native_command += 'X'
        else:
            native_command += str(axis_ct)

        formatted_axis = ( format(a,f".{self.post.values['FEED_PRECISION']}f") for a in axis )
        rez += f"{native_command},{','.join(formatted_axis)}" + nl
        print(f"### move\n{rez}###")

        return rez

    def set_speed( self, path_command, feed_rate ):
        # For non-rapid, F applies to the vector of all the axis
        # likewise, for Rapid, HorizRapid applies to the XY vector, and VertRapid to the Z
        native_command = None
        if path_command.Name == "G00":
            native_command = 'JS'
        else:
            native_command = 'MS'


        last_position = [ float(self.current_location[a] or 0) for a in self.AllowedAxis ]
        this_position = [ float(self.current_location[a] or 0) for a in self.AllowedAxis ] # so axis can be omitted from a command
        # update with the explicit positions
        for i,a in enumerate(self.AllowedAxis):
            if v:=path_command.Parameters.get(a,None):
                this_position[i] = v
        fmt_diff = lambda l:  [f"{p:9.3f}" for p in l]
        print(f"### Last {fmt_diff(last_position)}")
        print(f"### This {fmt_diff(this_position)}")

        d_axis = list(map(operator.sub, this_position, last_position))
        print(f"### d_axis {fmt_diff(d_axis)}")
        distance = math.sqrt( sum( [ v**2 for v in d_axis] ) )
        print(f"### dist {distance}")
        if path_command.Name == 'G00':
            rapid_speeds = [ 0.0 for a in self.AllowedAxis ]
            for i,a in enumerate([ 'JSXY', 'JSXY', 'JSZ' ]):
                rapid_speeds[i] = self.current_location[a]
            print(f"### rapid_speeds {fmt_diff(rapid_speeds)}")
            speeds = [ rapid_speeds[i] * d/distance for i,d in enumerate(d_axis) ]
        else:
            f = path_command.Parameters.get('F', None)
            print(f"### command f {f}")
            if f is None:
                f = self.current_location['F']
                print(f"### cur_loc f {f}")
            if f is None:
                raise ValueError(f"No previous F speed at {self.location(path_command)}")
            
            speeds = [ f * d/distance for d in d_axis ]

        speeds = [ format(s, f'.{self.post.values["AXIS_PRECISION"]}f') for s in speeds ]
        print(f"### fmt speeds {speeds}")
        cmd = f"{native_command},{','.join(speeds)}"
        print(f"### cmd {cmd}")
        return cmd + nl

    def set_initial_speeds(self, tool_controller, path_command):
        # need to ensure initial values for speeds
        # rapid-speed is never emitted by gcode, but we need to set it!
        # and we just set the initial speed for "feed" too

        print(f"### Setspeeds {tool_controller.Label}")
        native = ''

        native += self.comment(f"set speeds: {tool_controller.Label}")
        speeds = {
            "ms" : [], # x,y,z . x==y
            "has_ms" : 0, # each axis adds 1 to xyz=3
            "js" : [], # x,y,z . x==y
            "has_js" : 0, # each axis adds 1 to xyz=3
        }

        if tool_controller.HorizFeed != 0.0:
            speeds['has_ms'] += 2
            print(f"### setspeed tc horizf {tool_controller.HorizFeed.__class__.__name__}")

            xy = PostUtilsParse.format_for_feed(self.post.values, tool_controller.HorizFeed)
            speeds['ms'].append( xy )
            speeds['ms'].append( xy )
        else:
            speeds['ms'].append('')
            native += self.comment("no HorizFeed", force=True)
        if tool_controller.VertFeed != 0.0:
            speeds['has_ms'] += 1
            z = PostUtilsParse.format_for_feed(self.post.values, tool_controller.VertFeed )
            speeds['ms'].append( z )
        else:
            speeds['ms'].append('')
            speeds['ms'].append('')
            native += self.comment("no VertFeed", force=True)

        # fixme: where to get A&B values?
        #speeds['ms'].append('') # a-move-speed
        #speeds['ms'].append('') # b-move-speed

        if speeds['has_ms'] > 0:
            native += "MS," + ','.join( speeds['ms'] ) + "\n"

        if tool_controller.HorizRapid != 0.0:
            speeds['has_js'] += 2
            xy = PostUtilsParse.format_for_feed(self.post.values, tool_controller.HorizRapid )
            speeds['js'].append( xy )
            speeds['js'].append( xy )
        else:
            speeds['js'].append('')
            speeds['js'].append('')
            native += self.comment("no HorizRapid", force=True)

        if tool_controller.VertRapid != 0.0:
            speeds['has_js'] += 1
            z = PostUtilsParse.format_for_feed(self.post.values, tool_controller.VertRapid)
            speeds['js'].append( z )
        else:
            speeds['js'].append('')
            native += self.comment("no VertRapid", force=True)

        if speeds['has_js'] > 0:
            native += "JS," + ','.join( speeds['js'] ) + "\n"
            self.current_location['JSXY'] = float(speeds['js'][0])
            self.current_location['JSZ'] = float(speeds['js'][2])


        print(f"### setspeeds hasjs {speeds['has_js']} {speeds['js']}")
        if self.post.arguments.abort_on_unknown and speeds['has_js'] < 3:
            raise ValueError(f"ToolController <{self.post._job.Label}>.<{tool_controller.Label}> did not set xy&z rapid speeds, use --no-abort-on-unknown to allow at {self.location(path_command)}")
            
        return native

gcode_insertmap() # fixup DispatchMap
