# SPDX-License-Identifier: LGPL-2.1-or-later

# ***************************************************************************
# *   Copyright (c) 2014 sliptonic <shopinthewoods@gmail.com>               *
# *                                                                         *
# *   This file is part of the FreeCAD CAx development system.              *
# *                                                                         *
# *   This program is free software; you can redistribute it and/or modify  *
# *   it under the terms of the GNU Lesser General Public License (LGPL)    *
# *   as published by the Free Software Foundation; either version 2 of     *
# *   the License, or (at your option) any later version.                   *
# *   for detail see the LICENCE text file.                                 *
# *                                                                         *
# *   FreeCAD is distributed in the hope that it will be useful,            *
# *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
# *   GNU Lesser General Public License for more details.                   *
# *                                                                         *
# *   You should have received a copy of the GNU Library General Public     *
# *   License along with FreeCAD; if not, write to the Free Software        *
# *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
# *   USA                                                                   *
# *                                                                         *
# ***************************************************************************

from builtins import open as pyopen
import re
import sys
import importlib
import argparse
import datetime
import shlex
import FreeCAD
import Path
import Path.Post.Utils as PostUtils
from PathScripts import PathUtils


TOOLTIP = """
For ShopBot (or other opensbp controllers), this is a CAM postprocessor. We have to
translate gcode to opensbp, so the output is NOT gcode.

Special behaviors:
* This always sets the ShopBot machine units (see --inches --metric), no more mismatches. This defaults to your document's units.
* G54 (fixture/coordinate-system) is accepted, but is a noop (because it's the default in Operations). Others (G55 etc) are not-accepted.
* Like most post-processors, we accept single-digit gcodes like G1, and treat them as if they were canonical 2 digit, like G01.
* By default, this post-processor fails if it sees a gcode it doesn't understand. Cf. --abort-on-unknown and --skip-unknown
* opensbp prompt (dialog-box) behavior like this:
    (this comment becomes a prompt if followed by M00)
    M00
* Most optimizations assume that the instruction stream isn't interrupted with manually added commands (e.g. assumes the xyz position from the previous instructions). So, don't stop, and insert commands if you've used any of the optimizations.
* This always sets the move & jog speeds (feed and rapid) at the beginning of an operation, by fetching the Tool speeds (because some operations omit initial speeds).
* This does not filter out an operations's initial G0 X0 Y0 Z$safe, which is egregiously generated by some operations (notably dressups).
* If a Tool has a spindle speed, this always generates a dialog-box to prompt you.
* This generates a dialog-box for manual Tool changes (if it is a change), but not for the first tool (this assumes you've chucked the first tool).
* There is only very basic support for the A and B axis. This will probably do the wrong thing if not absolute degrees.
* Drill gcodes are not accepted (yet).
* This does arc gcodes (G02 and G03), so helical operations should work.
"""
"""
ToDo
    drilling.  Have outline, copy from estlcam_post or rrf_post
    fixtures/coordinate-systems. have outline.
"""

now = datetime.datetime.now()

PRECISION = 3 # default is metric
SKIP_UNKNOWN = [] # gcodes to skip if --abort-on-unknown

parser = argparse.ArgumentParser(prog="opensbp", add_help=False)
parser.add_argument("--header", action=argparse.BooleanOptionalAction, help="include header output. deafault=True", default=True)
parser.add_argument("--comments", action=argparse.BooleanOptionalAction, help="output comments (default=False)")
# opensbp can't do --line-numbers
parser.add_argument(
    "--show-editor",
    action=argparse.BooleanOptionalAction,
    help="don't pop up editor before writing output",
    default=True
)
# no default so that --inches/--metric can set the default for that mode
parser.add_argument("--precision", help=f"number of digits of precision, default=3 for metric, 4 for inches")
parser.add_argument(
    "--native-preamble",
    help='verbatim opensbp commands to be issued before the first command, multi-line w/ \\n. Before preamble. Consider a "Cn" or "FB". default=None',
)
parser.add_argument(
    "--preamble",
    help='set g-code commands to be issued before the first command, multi-line g-code w/ \\n, default=None',
)
parser.add_argument("--return-to", help="Move to x,y,z,a,b coordinates at the end (before postamble), e.g --return-to 0,0. empty for an axis, or omit trailing to not move in that axis. default is don't return-to")
parser.add_argument(
    "--postamble",
    help='set g-code commands to be issued after the last command, multi-line g-code w/ \\n, default=None',
)
parser.add_argument(
    "--native-postamble",
    help='verbatim opensbp commands to be issued after the last command, multi-line w/ \\n. After postamble. Consider a "Cn" or "FB". default=None',
)
# parser.add_argument("--o1", action="store_true", help='turns on optimizations that wouldn't break if you interrupt the execution and did some command manually.') # no such optimizations at this time
# These optimizations assume that you don't interrupt execution to insert a manual command (e.g. imagine a MS 400; and MX,1. which would break all the modal assumptions)
parser.add_argument("--o2", action="store_true", help='turns on --modal --axis-modal --speed-modal')
parser.add_argument(
    # nb, no 'default=' so we can use the App.ActiveDocument.UnitSystem setting
    "--metric", action="store_true", help="Convert output for US imperial mode, default=document unit system"
)
parser.add_argument(
    # nb, no 'default=' so we can use the App.ActiveDocument.UnitSystem setting
    "--inches", action="store_true", help="Convert output for imperial decimal mode, default=document unit system"
)
parser.add_argument("--axis-modal", action=argparse.BooleanOptionalAction, help="Shorten output when axis-values don't change", default=False)
parser.add_argument("--modal", action=argparse.BooleanOptionalAction, help="Shorten output when a modal command repeats for no effect", default=False)
parser.add_argument("--speed-modal", action=argparse.BooleanOptionalAction, help="Shorten output when speed-values don't change", default=False)
parser.add_argument(
    # this should probably be True for most shopbot installations
    "--ab-is-distance", action="store_true", help="A & B axis are distances, default=degrees"
)
parser.add_argument("--filter","--filters", help="a ',' list of filters in FreeCAD.getUserMacroDir()/post to run on the gcode of each Path object, before we see it (i.e. cleanups). A class of same (camelcase) name as file, __init__(self,objectslist, filename, argstring), .filter(eachpathobj, its-.Commands) -> gcode")
parser.add_argument("--abort-on-unknown", action=argparse.BooleanOptionalAction, help="Generate an error and fail if an unknown gcode is seen. default=True", default=True)
parser.add_argument("--skip-unknown", help="if --abort-on-unknown, allow these gcodes, change them to a comment. E.g. --skip-unknown G55,G56")
parser.add_argument("--toolchanger", action=argparse.BooleanOptionalAction, help="Use auto-tool-changer (macro C9), default=manual", default=False)
parser.add_argument("--spindle-controller", action=argparse.BooleanOptionalAction, help="Has software controlled spindle speed, default=manual", default=False)
parser.add_argument("--wait-for-spindle", type=int, help="How long to wait after a spindle-speed change, only if --spindle-controller. Default=3", default=3)
parser.add_argument("--gcode-comments", action=argparse.BooleanOptionalAction, help="Add the original gcode as a comment, for debugging", default=False)

TOOLTIP_ARGS = parser.format_help()
Arguments = None # updated at export() time with parser.parse_args

ALLOWED_AXIS = ["X", "Y", "Z", "A", "B"]  # also used for --modal optimization
CurrentState = {}

def getMetricValue(val):
    return val

def getImperialValue(val):
    return val / 25.4

GetValue = getMetricValue
FloatPrecision = None # setup in processArguments
Filters = [] # setup in processArguments
Optimizing = {
    # placeholder for which things will could optimize
}
Units = None
ExplicitUnits = None

def processArguments(argstring):

    global PRECISION
    global SKIP_UNKNOWN
    global GetValue
    global FloatPrecision
    global Units
    global ExplicitUnits
    global Arguments
    global Filters

    # re-init each time
    Filters = []
    PRECISION = 3
    SKIP_UNKNOWN = []
    GetValue = getMetricValue
    FloatPrecision = None # setup in processArguments
    Filters = [] # setup in processArguments
    Units = None
    ExplicitUnits = False # was --inches or --metric specified?

    Arguments = parser.parse_args(shlex.split(argstring))

    # Use App.ActiveDocument.UnitSystem
    # I don't know how to decode that string to "inches" vs "mm"
    # But, FreeCAD.Units.Quantity('1mm').getUserPreferred()
    #   will give the units for the ACTIVE DOCUMENT

    # .getUserPreferred() e.g. ('0.0010 m', 1000.0, 'm')
    user_units = FreeCAD.Units.Quantity('1mm').getUserPreferred()[2]
    if user_units in {'ft','in','thou'}: # FIXME: better way to get 'inches' or 'metric'
        Units = "inches"
        GetValue = getImperialValue
        PRECISION = 4
    else:
        # for anything else we'll use mm
        Units = "metric"
        GetValue = getMetricValue
        PRECISION = 3

    if Arguments.o2:
        Arguments.modal = True
        Arguments.axis_modal = True
        Arguments.speed_modal = True

    if Arguments.inches:
        GetValue = getImperialValue
        PRECISION = 4
        Units="inches"
        ExplicitUnits = True

    if Arguments.metric:
        GetValue = getMetricValue
        PRECISION = 3
        Units="metric"
        ExplicitUnits = True

    if Arguments.precision is not None:
        PRECISION = int(Arguments.precision)

    FloatPrecision = f".{PRECISION}f"

    if Arguments.skip_unknown is not None:
        SKIP_UNKNOWN = Arguments.skip_unknown.split(',')

    if Arguments.filter is not None:
        # allow _filter.py suffix
        filter_names = ( re.sub(r'_filter$', '', re.sub(r'\.py$','',x)) for x in Arguments.filter.split(','))
        for f in filter_names:
            module_name = f"post.{f}_filter"
            was = module_name in sys.modules
            m = importlib.import_module(module_name)
            if was:
                # especially during development of the filter
                importlib.reload(m)
            # module is post.x_filter, just want the x_filter part for the class name
            klass = (module_name.split('.')[1]).title().replace('_','')

            # We do not new() here, so Filters is a list of classes!
            fobj = getattr(m,klass) # (objectslist, filename, argstring)
            Filters.append(fobj)

def set_speeds_before_tool_change(obj):
    # on tool change, expicitly set speeds to compensate for missing F parameters on early movements
    # Only call us for isinstance(obj.Proxy, ToolController)

    gcode = ''

    # Shouldn't happen in real use, but happens during unit-testing
    if 'UNDER_UNITTEST' in globals() and obj is None:
        return ''

    gcode += comment(f"(set speeds: {obj.Label})", True)
    speeds = {
        "ms" : [],
        "has_ms" : False,
        "js" : [],
        "has_js" : False,
    }

    has_speed = False # skip initial speed-set if no speeds

    if obj.HorizFeed != 0.0:
        speeds['has_ms'] = True
        xy = format( GetValue(FreeCAD.Units.Quantity(obj.HorizFeed.getValueAs('mm/s')).Value),f".{PRECISION}f" )
        speeds['ms'].append( xy )
        speeds['ms'].append( xy )
    else:
        ms.append('')
        gcode += comment("(no HorizFeed)", True)
    if obj.HorizFeed != 0.0:
        speeds['has_ms'] = True
        z = format( GetValue(FreeCAD.Units.Quantity(obj.VertFeed.getValueAs('mm/s')).Value),f".{PRECISION}f" )
        speeds['ms'].append( z )
    else:
        speeds['ms'].append('')
        gcode += comment("(no VertFeed)", True)

    # fixme: where to get A&B values?
    #speeds['ms'].append('') # a-move-speed
    #speeds['ms'].append('') # b-move-speed

    if speeds['has_ms']:
        gcode += "MS," + ','.join( speeds['ms'] ) + "\n"

    if obj.HorizRapid != 0.0:
        speeds['has_js'] = True
        xy = format( GetValue(FreeCAD.Units.Quantity(obj.HorizRapid.getValueAs('mm/s')).Value),f".{PRECISION}f" )
        speeds['js'].append( xy )
        speeds['js'].append( xy )
    else:
        vs.append('')
        gcode += comment("(no HorizRapid)", True)

    if obj.VertRapid != 0.0:
        speeds['has_js'] = True
        z = format( GetValue(FreeCAD.Units.Quantity(obj.VertRapid.getValueAs('mm/s')).Value),f".{PRECISION}f" )
        speeds['js'].append( z )
    else:
        vs.append('')
        gcode += comment("(no VertRapid)", True)

    if speeds['has_ms']:
        gcode += "JS," + ','.join( speeds['js'] ) + "\n"

    return gcode

def export(objectslist, filename, argstring):
    global CurrentState
    global Filters

    FreeCAD.Console.PrintMessage("postprocessing...\n")

    for obj in objectslist:
        if not hasattr(obj, "Path"):
            FreeCAD.Console.PrintError( f"the object {obj.Name if 'Name' in dir(obj) else obj.__class__.__name__} is not a path. Please select only path and Compounds.\n" )
            # Other postprocessors skip it
            return ''

    CurrentState = {
        "gcode_line_number" : 0,
        "X": 0,
        "Y": 0,
        "Z": 0,
        "A": 0,
        "B": 0,
        "C": None, "U": None, "V": None, "W": None, # axis not available
        "JSXY": 0,
        "JSZ": 0,
        "MSXY": 0,
        "MSZ": 0,
        "Tool" : None, # None on first time, then the number
        "ToolController" : None, # a toolcontroller object from the document
        "Absolute" : True, # G91 puts in relative
        "Operation" : None, # updated in translate_commands() when we start each operation
        "LastCommand" : None, # updated in translate_commands() 
        "LastGCode" : None, # updated in translate_commands()
    }
    gcode = ""

    processArguments(argstring)

    # need to instantiate filters now that we have the full args
    Filters = [ x(objectslist, filename, argstring) for x in Filters]

    # write header
    if Arguments.header:
        # not using comment(), the --header option overrides --no-comments
        gcode += comment( f"Exported by FreeCAD {'.'.join(FreeCAD.Version()[:3])}", True, force=True)
        gcode += comment(f"Post Processor: {__name__[:-5]}", True, force=True)
        gcode += comment(f"  {argstring}", True, force=True)
        # there are "temp" objects that don't give a good ParentJob
        first_real_object = next((x for x in objectslist if 'Proxy' in dir(x)),None)
        gcode += comment(f"Job: {PathUtils.findParentJob(first_real_object).Label if first_real_object else ''}", True, force=True)
        gcode += comment(f"Output Time: {now}", True, force=True)
        for f in Filters:
            gcode += comment(f"Filter: {f.__class__.__name__}", True, force=True)

    def str_to_gcode(s, during):
        # one gcode
        # e.g. str_to_gcode("G0 X50")
        pc = Path.Command()
        try:
            pc.setFromGCode(s)
        except ValueError as e:
            # can't tell if it is really 'Badly formatted GCode argument', so just add our gcode to the message
            message = f"During {during}, gcode: {s}"
            FreeCAD.Console.PrintError(message)
            raise ValueError(message) from e
        return pc

    # switch machine to our units
    if ExplicitUnits:
        gcode += comment(f"(set to explicit units {Units})", True)
    else:
        gcode += comment(f"(use default machine units (document units were {Units}))", True)
    # save and restore at end
    gcode += "&WASUNITS=%(25)\n"
    vd =  { 'inches' : "VD,,,0", 'metric' : "VD,,,1" }
    gcode += vd[Units] + "\n"

    if Arguments.native_preamble:
        comment('(native preamble)',True)
        pre_lines = Arguments.native_preamble.replace('\\n','\n')
        if not pre_lines.endswith("\n"):
            pre_lines += "\n"
        gcode += pre_lines

    if Arguments.preamble:
        gcode += comment('(begin preamble)',True)
        preamble_lines = Arguments.preamble.replace('\\n','\n').splitlines(False)
        preamble_commands = [ str_to_gcode(x, "--preamble") for x  in preamble_lines ]
        gcode += translate_commands( preamble_commands )

    for obj in objectslist:
        # Order: Fixture, ToolControl, Path, repeat

        # so we can get speeds and tool-name etc deeper in the objects
        if hasattr(obj, "Proxy") and isinstance(obj.Proxy, Path.Tool.Controller.ToolController):
            CurrentState['ToolController'] = obj # .Tool.Label is the tool name

        # do the pre_op
        if hasattr(obj, "Proxy") and isinstance(obj.Proxy, Path.Op.Base.ObjectOp):
            CurrentState['Operation'] = obj
        gcode += comment(f"(begin operation: {obj.Label})", True)

        gcode += parse(obj)

        # do the post_op
        gcode += comment(f"(finish operation: {obj.Label})", True)

    if Arguments.return_to:
        # x,y,z,a,b
        # can omit any trailing ones which won't change
        # can use empty to mean "don't change". e.g. --return-to ,0 # means only y to zero
        possible_axis = ['X','Y','Z','A','B']
        try:
            coords = [
                f"{possible_axis[i]}{float(x)}"
                for i,x in enumerate(Arguments.return_to.split(','))
                if x != ''
            ]
        except ValueError as e:
            message = f"Expected float-values in --return-to '{Arguments.return_to}'"
            FreeCAD.Console.PrintError(message)
            raise ValueError(message) from e
        else:
            gcode += comment("(return-to)", True)
            return_to_gcode= f"G0 {' '.join(coords)}"
            return_to = str_to_gcode( return_to_gcode, "--return-to" )
            gcode += translate_commands( [return_to], modal=False )

    if Arguments.postamble:
        gcode += comment('(begin postamble)',True)
        postamble_lines = Arguments.postamble.replace('\\n','\n').splitlines(False)
        postamble_commands = [ str_to_gcode(x, "--postamble") for x  in postamble_lines ]
        gcode += translate_commands( postamble_commands )

    # restore units
    gcode += f"VD,,,&WASUNITS\n"

    if Arguments.native_postamble:
        comment('(native postamble)',True)
        post_lines = Arguments.native_postamble.replace('\\n','\n')
        if not post_lines.endswith("\n"):
            post_lines += "\n"
        gcode += post_lines

    if Arguments.show_editor:
        dia = PostUtils.GCodeEditorDialog()
        dia.editor.setText(gcode)
        result = dia.exec_()
        if result:
            final = dia.editor.toPlainText()
        else:
            final = gcode
    else:
        final = gcode

    FreeCAD.Console.PrintMessage(f"done postprocessing. {CurrentState['gcode_line_number']} gcodes.\n")

    # Write the output
    if filename != "-":
        with pyopen(filename, "w") as gfile:
            gfile.write(final)

    return final

def gcodecomment(command,prefix=''):
    # return the gcode as a trailing comment if appropriate
    return f" '{prefix}{command.toGCode()}" if Arguments.gcode_comments else ''

def adjust_speed(command, axis):
    # Handle speed change
    txt = ''
    if "F" in command.Parameters:
        if normalized(command.Name) in RAPID_COMMANDS: # jog
            movetype = "JS"
        else:  # move
            movetype = "MS"

        speed = command.Parameters["F"]
        zspeed = ""
        xyspeed = ""
        if "Z" in axis:
            speed_key = "{}Z".format(movetype)
            speed_val = GetValue(speed)
            if not Arguments.speed_modal or CurrentState[speed_key] != speed_val:
                CurrentState[speed_key] = speed_val
                zspeed = format(speed_val, f".{PRECISION}f")
        if ("X" in axis) or ("Y" in axis):
            speed_key = f"{movetype}XY"
            speed_val = GetValue(speed)
            if not Arguments.speed_modal or CurrentState[speed_key] != speed_val:
                CurrentState[speed_key] = speed_val
                xyspeed = format(speed_val, f".{PRECISION}f")

        if "A" in axis or "B" in axis:
            opname = CurrentState['Operation'].Label if CurrentState['Operation'] else ''
            FreeCAD.Console.PrintWarning("WARNING: we aren't handling speed for A and B axis in [{CurrentState['gcode_line_number']}] {opname} {command.toGCode()}\n")

        if zspeed or xyspeed:
            txt += f"{movetype},{xyspeed},{zspeed}{gcodecomment(command)}\n"

    return txt

def axis_list(command):
    # which axis are in this command that we should emit
    axis = ""
    # we don't do CUVW
    for p in ("C", "U", "V", "W"):
        if p in command.Parameters:
            opname = CurrentState['Operation'].Label if CurrentState['Operation'] else ''
            message = f"We can't do axis {p} (or any of CUVW) in [{CurrentState['gcode_line_number']}] {opname} {command.toGCode()}"
            FreeCAD.Console.PrintError(message)
            raise NotImplementedError(message)

    for p in ALLOWED_AXIS : # we don't do CUVW
        if p in command.Parameters:
            if Arguments.axis_modal:
                # FIXME: does --axis-modal mean "only vs immediately preceding command?"
                # we are doing "vs current state"
                if (
                    (CurrentState['Absolute'] and command.Parameters[p] != CurrentState[p])
                    or (not CurrentState['Absolute'] and command.Parameters[p] != 0)
                ):
                    axis += p
            else:
                axis += p
    return axis

def pause(command):
    # Prompt with "Continue?" and pause, wait for user-interaction
    # If a comment precedes M00, that is used as the prompt (to emulate opensbp behavior)

    txt = ''
    if CurrentState['LastCommand'] != 'comment':
        txt += comment("Continue?", True, force=True)
    elif CurrentState['LastCommand'] == 'comment' and not Arguments.comments:
        # Force inclusion of that comment as a prompt
        txt += comment( CurrentState['LastGCode'], force=True )
    txt += "PAUSE\n"
    return txt

def move(command):
    txt = ""

    axis = axis_list(command)

    txt += adjust_speed(command, axis)

    # Actual move

    if normalized(command.Name) == "G00":
        pref = "J"
    else:
        pref = "M"

    txt_len_before_move = len(txt) # for detection to do +gcodecomment and \n

    if len(axis) == 1:
        # axis string is key and command-second-letter
        txt += pref + axis
        if axis in {'A','B'} and not Arguments.ab_is_distance:
            txt += "," + format(command.Parameters[axis], FloatPrecision)
        else:
            txt += "," + format(GetValue(command.Parameters[axis]), FloatPrecision)
    elif axis == "XY":
        txt += pref + "2"
        txt += "," + format(GetValue(command.Parameters["X"]), FloatPrecision)
        txt += "," + format(GetValue(command.Parameters["Y"]), FloatPrecision)
    elif axis in { "XZ", "YZ", "XYZ" }:
        # anything plus Z requires the 3 arg version
        txt += pref + "3"
        for key in ('X','Y','Z'):
            txt += "," + format(GetValue(command.Parameters[key]), FloatPrecision) if key in axis else ''
    elif ('A' in axis or 'B' in axis) and len(axis)>1 and not next( ( c for c in 'CUVW' if c in axis), None):
        # AB+ needs "5" version (carefully excluding CUVW)
        # we could optimize to an M4 if just A
        txt += pref + "5"
        for key in ('X','Y','Z','A','B'):
            if key in {'A','B'} and not Arguments.ab_is_distance:
                txt += "," + format(command.Parameters[key], FloatPrecision) if key in axis else ''
            else:
                txt += "," + format(GetValue(command.Parameters[key]), FloatPrecision) if key in axis else ''
    elif axis == "":
        #print("warning: skipping duplicate move.")
        pass
    else:
        opname = CurrentState['Operation'].Label if CurrentState['Operation'] else ''
        message = f"I don't know how to handle '{axis}' for a move in [{CurrentState['gcode_line_number']}] {opname} {command.toGCode()}"
        FreeCAD.Console.PrintWarning(CurrentState+"\n")
        FreeCAD.Console.PrintWarning(command.toGCode() + "\n")
        FreeCAD.Console.PrintError(message)
        raise NotImplementedError(message)

    # common line endings
    if len(txt) != txt_len_before_move:
        txt += gcodecomment(command)
        txt += "\n"
    
    return txt

def arc(command):
    # only center-format: IJ
    # only absolute mode
    # only xy plane
    # cases:
    #   current-position is start
    #   Z causes helical-arc
    #   Pn causes arc-as-defined + (n-1) whole circles: not handled
    #   XY is the end-position for a segment
    #   none of XY means whole circle
    #   IJ is the location of the arc-center: an offset. at least one of is required
    #   F is required

    # we would have to generate multiple CG's for repetitions (P)
    not_handled_parameters = [ 'P', 'R' ]
    # we handle K=0.0 by ignoring it (xy-plane), other K's we don't handle
    if 'K' in command.Parameters and command.Parameters['K'] != 0.0:
        not_handled_parameters.append('K')
    not_handled = [ a for a in command.Parameters if a in not_handled_parameters ]
    if not_handled:
        opname = CurrentState['Operation'].Label if CurrentState['Operation'] else ''
        message = f"We can't do parameters {not_handled} for an arc in [{CurrentState['gcode_line_number']}] {opname} {command.toGCode()}"
        FreeCAD.Console.PrintError(message)
        if Arguments.abort_on_unknown:
            raise NotImplementedError(message)
        else:
            return ''
    
    if not CurrentState['Absolute']:
        opname = CurrentState['Operation'].Label if CurrentState['Operation'] else ''
        message = f"We can't do relative mode for arcs in [{CurrentState['gcode_line_number']}] {opname} {command.toGCode()}"
        FreeCAD.Console.PrintError(message)
        if Arguments.abort_on_unknown:
            raise NotImplementedError(message)
        else:
            return ''

    if normalized(command.Name) == "G02":  # CW
        dirstring = "1"
    else:  # G3 means CCW
        dirstring = "-1"
    txt = ""

    axis = axis_list(command)

    txt += adjust_speed(command, axis+"XY") # always xy

    txt += "CG,"
    txt += "," # no diameter
    # end
    if 'X' not in command.Parameters and 'Y' not in command.Parameters:
        # circle
        txt += ","
        txt += ","
    else:
        # segment
        txt += format(GetValue(command.Parameters["X"]), f".{PRECISION}f") + ","
        txt += format(GetValue(command.Parameters["Y"]), f".{PRECISION}f") + ","
    # Center is at offset:
    txt += format(GetValue(command.Parameters["I"]) if 'I' in command.Parameters.keys() else 0.0, f".{PRECISION}f")  + ","
    txt += format(GetValue(command.Parameters["J"]) if 'J' in command.Parameters.keys() else 0.0, f".{PRECISION}f")  + ","
    txt += "T" + "," # move on diameter
    txt += dirstring + ","

    if 'Z' in command.Parameters:
        # Z causes a helical, "causes the defined plunge to be made gradually as the cutter is circling down"
        plunge = GetValue(command.Parameters["Z"]) - CurrentState['Z'] # negative for plunge down
        txt += format(plunge, f".{PRECISION}f") + ","
    else:
        plunge = 0
        txt += "0,"

    txt += "," # repetitions
    txt += "," # proportion-x
    txt += "," # proportion-y
    if 'Z' in command.Parameters:
        # helical cases
        # we don't do "bottom pass" (4) because FreeCAD seems to do that and it's not a g-code thing anyway
        if 'X' not in command.Parameters and 'Y' not in command.Parameters:
            # circle
            feature = 3 # spiral
        else:
            feature = 3 # spiral
    else:
        feature = 0

    txt += f"{feature},"
    txt += "1," # continue the CG plunging (don't pull up)
    txt += "0" # no move before plunge

    # actual Z, opensbp plunge is a delta, note the actual Z as a comment
    if 'Z' in command.Parameters:
        txt += " ' Z" + format(GetValue(command.Parameters["Z"]), f".{PRECISION}f")
    txt += gcodecomment(command)
    txt += "\n"
    return txt

def tool_change(command):
    txt = ""
    txt += comment("(tool change)", True)
    tool_number = int(command.Parameters['T'])
    tool_name = CurrentState['ToolController'].Tool.Label if CurrentState['ToolController'] else str(tool_number)

    txt += f"&Tool={tool_number}{gcodecomment(command)}\n"
    if Arguments.toolchanger:
        txt += "C9 'toolchanger\n"
    else:

        # assume the first tool is already installed (for manual)
        if CurrentState['Tool'] is None:
            txt += comment(f"(First change tool, should already be #{tool_number}: {tool_name})",True)
        else:
            txt += f"'Change tool to #{tool_number}: {tool_name}\n" # prompt
            txt += "PAUSE\n" # causes a modal to ask "ok?"
        CurrentState['Tool'] = tool_number
    # after C9
    # Don't know actual rules for strings, but need to quote lest a & gets interpreted
    tool_name = re.sub(r'[^A-Za-z0-9/_ .-]', '', tool_name)
    txt += f'&ToolName="{tool_name}"\n'


    # As of FreeCAD 1.0.2, early movements don't emit a F, so there is no "current" speed
    # Since a tool-change is issued 1st (and when appropriate), we'll set the current speed here
    txt += set_speeds_before_tool_change(CurrentState['ToolController'])

    return txt

def comment(command, keepparens=False, force=False):
    # comments from gcode are stripped of ()
    # comments we generate include ()

    # from gcode stream, it's a Path.Command
    # from internal use, it's a str
    if isinstance(command, Path.Command):
        command = command.Name

    if Arguments.comments or force:
        return f"'{command if keepparens else command[1:-1]}\n"
    else:
        #print("a comment", command)
        return ''

def absolute_positions(command):
    CurrentState['Absolute'] = True
    return comment("Absolute Positions", True) + "SA 'ABSOLUTE\n"


def relative_positions(command):
    CurrentState['Absolute'] = False
    return comment("Relative Positions", True) + "SR 'RELATIVE\n"

def spindle(command):
    txt = ""
    if normalized(command.Name) == "M03":  # CW
        pass
    else:
        pass
    txt += f"TR,{int(command.Parameters['S'])}\n"
    if Arguments.spindle_controller:
        txt += "C6 'spindle-controller\n"
        if Arguments.wait_for_spindle > 0:
            txt += f"PAUSE {Arguments.wait_for_spindle}\n"
    else:
        txt += f"'Change spindle speed to {int(command.Parameters['S'])}\n" # prompt
        txt += "PAUSE\n" # causes a modal to ask "ok?"

    return txt

def coordinate_system(command):
    txt = ''

    gpart = command.Name

    which = 0 # safety

    # Parsing for all of them, but we only support G54
    if gpart == "G54.1":
        which = int(command.Parameters['P'])
    elif m := re.match(r'G5([45678])', gpart):
        which = int(m.group(1)) - 3 # starts at 1
    elif gpart == "G59":
        if 'P' in command.Parameters:
            which = int(command.Parameters['P'])
        else:
            which = 6
    elif m := re.match(r'G59\.([123])', gpart):
        which = 6 + int(m.group(1))

    if which != 1:
        opname = CurrentState['Operation'].Label if CurrentState['Operation'] else ''
        message = f"coordinate-system not supported (only G54/1) in [{CurrentState['gcode_line_number']}] {opname} {command.toGCode()}"
        FreeCAD.Console.PrintError(message)
        raise NotImplementedError(message)

    else:
        txt += comment(f"G54 has no effect{gcodecomment(command)}", True)

    return txt

# Supported Commands
SUPPORTED_COMMANDS = {
    # single digit Gn's are normalized to G00 before a fn sees them
    # "rapid" is used to change jog-speed (otherwise it's move-speed)
    "G00": { "fn" : move, "rapid" : True },
    "G01": { "fn" : move },
    "G02": { "fn" : arc },
    "G03": { "fn" : arc },
    "M06": { "fn" : tool_change },
    "M03": { "fn" : spindle },
    "G91" : { "fn" : relative_positions },
    "G90" : { "fn" : absolute_positions },
    "G54" : { "fn" : coordinate_system },
    "M00" : { "fn" : pause },

    "comment": { "fn" : comment },
}
# For setting speeds, need to distinguish feed vs rapid
RAPID_COMMANDS = { k for k,info in SUPPORTED_COMMANDS.items() if info.get("rapid",False) }

def filter_gcode(pathobj, path_commands):
    # an iterable of Path.Commands
    # we return the filtered commands
    filtered = path_commands # in case there are no filters
    for f in Filters:
        filtered = f.filter(pathobj, filtered)
    return filtered

def parse(pathobj):
    output = ""

    if hasattr(pathobj, "Group"):  # We have a compound or project.
        output += comment(f"(compound: {pathobj.Label})", True)
        for p in pathobj.Group:
            output += parse(p)
    else:  # parsing simple path

        # groups might contain non-path things like stock.
        if not hasattr(pathobj, "Path"):
            return output

        output += comment(f"(Path: {pathobj.Label})", True)

        # FIXME: the use of getPathWithPlacement() causes a yaw-pitch calculation which gives odd AB values
        # so, tests disabled for those
        # no-other post-procesor tests AB (except linuxcnc which does not do getPathWithPlacement())

        # we filter each pathobj
        # and then translate
        output += translate_commands( filter_gcode(pathobj, PathUtils.getPathWithPlacement(pathobj).Commands) )

    return output

def normalized(gcode_name):
    # normalize single digit Gn to G0n
    # for M's too
    return re.sub(r'^([A-Z])([0-9])$',r'\g<1>0\g<2>', gcode_name)

def translate_commands(commands, modal=None):
    # `modal` overrides --modal --axis-modal --speed-modal
    output = ""
    for c in commands:
        CurrentState['gcode_line_number'] += 1 # i.e. from Freecad gcode

        if c.Name.startswith("("):
            command = 'comment'
        else:
            command = normalized(c.Name)

        if command in SUPPORTED_COMMANDS:
            # skip duplicate commands
            if Arguments.modal and c.toGCode() == CurrentState['LastGCode']:
                # Don't elide movements if relative motion, it isn't a noop!
                if set(ALLOWED_AXIS) & set( c.Parameters.keys() ):
                    if CurrentState['Absolute']:
                        continue
                # non-movements don't care about relative
                else:
                    continue
            
            modal_overrides = ['modal','axis_modal','speed_modal']
            was_model_override_values = {}
            if modal is not None:
                # set the override and remember
                for arg in modal_overrides:
                    was_model_override_values[arg] = getattr(Arguments,arg)
                    setattr(Arguments, arg, modal)

            output += SUPPORTED_COMMANDS[command]['fn'](c)

            if modal is not None:
                # restore modals from the override
                for arg,value in was_model_override_values.items():
                    setattr(Arguments, arg, value)

            # Track axis positions
            # other current-state must be handled in each command translator (e.g. JSXY)
            if c.Parameters:
                for k in ALLOWED_AXIS:
                    if k in c.Parameters:
                        CurrentState[k] = c.Parameters[k] if CurrentState['Absolute'] else (CurrentState[k] + c.Parameters[k])
        elif command == '':
            # skip empties
            pass
        else:
            opname = CurrentState['Operation'].Label if CurrentState['Operation'] else ''
            message = f"gcode not handled in [{CurrentState['gcode_line_number']}] {opname} {c.toGCode()}"
            if Arguments.abort_on_unknown and command not in SKIP_UNKNOWN:
                FreeCAD.Console.PrintError(message+"\n")
                raise NotImplementedError(message)
            else:
                output += comment(message, True, force=True)
                FreeCAD.Console.PrintWarning("Skipped: " + message + "\n")

        CurrentState['LastGCode'] = c.toGCode()
        CurrentState['LastCommand'] = command # not quite the same as c.Command (e.g. "comment")
    return output

# print(__name__ + " gcode postprocessor loaded.")
